#!/usr/bin/perl
#Dependencies:
#dd
#losetup
#mkdir
#mount
#debootstrap
#umount
#rmdir

use strict;
use warnings;
use Getopt::Long;
Getopt::Long::Configure ('bundling');

#Check to make sure user is root
my $user = `whoami`;
chomp $user;
if($user ne 'root'){
  print 'Superuser privileges are necessary for some parts of this script; ';
  print 'use sudo.' . "\n";
  exit(1);
}

#################
#  Global Vars  #
#################

#General
my $verbose = 0;
my $help;
my $count = 4;
my $location = './';
my $uuid = 'test';
my $dev_device = 0;
my $clean = 0;
my $swap_size_mb = 128;
my $free_size_mb = 128;

#Debootstrap Options
my $arch = 0;
my $apt_include = 0;
my $distro = 'gutsy';
my $mirror = 0;


#DD Config Options
my $dd_bs = 1024*1024;

GetOptions ('a|arch=s' => \$arch,
            'd|distro=s' => \$distro,
            'l|location=s' => \$location,
            'm|mirror=s' => \$mirror,
            'ddbs=i' => \$dd_bs,
            'h|help' => \$help,
            'v' => \$verbose,
            'clean' => \$clean);

# Display help
if($help || ($#ARGV+1) != 1){
  print 'Usage: [options] imagename' . "\n";
  print "  -c [count], --count [count]\t\t\tNumber of IMGs to Create\n";
  print "  -a [arch], --arch [arch]\t\t\tArchitecture to Install\n";
  print "  -d [distro], --distro [distro]\t\tDistro to Install\n";
  print "  -l [location], --location [location]\t\tLocation to Create IMGs\n";
  print "  -m [mirror], --mirror [mirror]\t\tMirror to Intall from\n";
  print "  --ddbs [size]\t\t\t\t\tBS for DD command\n";
  print "  --ddcount [count]\t\t\t\tCount for DD command\n";
  print "  -s [count], --ddseek [count]\t\t\tSeek for DD command\n";
  print "  --clean\t\t\t\tclean old image build\n";
  print "  -v\t\t\t\tverbose\n";
  print "  -h --help\t\t\t\t\tThis.\n";
  exit(1);
}
#Parse Command Line vars after options
$uuid = $ARGV[0];
my $img_name = $uuid . '.img';
my $mount_dir = $location . 'mnt-' . $uuid;
my $dbs_dir = $location . 'tmp-' . $uuid;

#################
#  Subroutines  #
#################

my $logfilename="creator.log.$uuid";
open(LOGFILE, ">$logfilename") or die("Unable to open logfile: $logfilename");

sub log_info {
  print LOGFILE "$_[0]\n";
  print "$_[0]\n";
}

sub log_fatal {
  print LOGFILE "$_[0]\n";
  print "$_[0]\n";
  clean_env();
  exit(1);
}

sub ex_quiet {
  my($command,$name,$do_not_fatal) = @_;
  if ($name) {
    log_info("TASK: $name");
  }
  if ($verbose) {
    log_info("COMMAND: $command");
  }
  my $ret = `$command 2>&1`;
  if ($? != 0) {
    log_info("OUTPUT: $ret\n");
    if ($do_not_fatal) {
      log_info("ERROR: Return Code $?\n");
    } else {
      log_fatal("ERROR: Return Code $?\n");
    }
  }
  chomp($ret);
  return $ret;
}

sub ex_verbose {
  my($command,$name) = @_;
  if ($name) {
    log_info("TASK: $name");
  }
  if ($verbose) { 
    log_info("COMMAND: $command");
  }
  system("$command");
  if ($? != 0) {
    log_fatal("ERROR: Return Code $?");
  }
}

sub clean_env() {
#  ex_quiet('rm -rf ' . $dbs_dir,
#           "[CLEAN] Removing Temporary Deboostrap Directory", 1);
  ex_quiet('umount ' . $mount_dir, "[CLEAN] Unmounting Temporary Directory", 1);
  if($dev_device) {
    ex_quiet('kpartx -dv ' . $dev_device,
             "[CLEAN] Removing Partition Device Mappings");
    ex_quiet('losetup -d ' . $dev_device,
             "[CLEAN] Removing Loopback Device", 1);
  } else {
    log_info("[CLEAN] Could not find dev device for losetup -d");
  }
  ex_quiet('rmdir ' . $mount_dir, "[CLEAN] Removing Temporary Directory", 1);
}

sub mkdebootstrapcommand {
  my $debootstrapcommand = 'debootstrap ';
  if ($arch) {
    $debootstrapcommand .= '--arch ' . $arch . ' ';
  }
  if ($apt_include) {
    $debootstrapcommand .= '--include=' . $apt_include . ' ';
  }
  $debootstrapcommand .= $distro . ' ' . $dbs_dir;
  if ($mirror) {
    $debootstrapcommand .= ' ' . $mirror;
  }
  return $debootstrapcommand;
}

###########
#   Run   #
###########

if($clean) {
  clean_env();
  exit(0);
}


#ex_quiet('mkdir -p ' . $dbs_dir, "Creating Temporary Debootstrap Directory");
#ex_verbose(mkdebootstrapcommand(), "Creating base guest filesystem");
my $image_base_size_b = ex_quiet("du -s -b " . $dbs_dir . " | awk '{print \$1}'",
                                 "Getting base image size");
log_info('INFO: Base image size is: ' . $image_base_size_b);

my $image_size_b = $image_base_size_b + ($swap_size_mb*1024*1024) + 
                   ($free_size_mb*1024*1024);
log_info('INFO: Final image size will be: ' . $image_size_b);
ex_quiet('dd if=/dev/zero of=' . $location . $img_name . ' ' . 'bs=' . 
         $dd_bs . ' count=' . int($image_size_b/$dd_bs),
         "Creating image file");
$dev_device = ex_quiet('losetup -f', "Getting Free Loopback Device");
log_info('INFO: Found free loopback device: ' . $dev_device);
ex_quiet('losetup ' . $dev_device . ' ' . $location . $img_name,
         "Creating Loopback Block Device");
ex_quiet('parted --script ' . $dev_device . ' mklabel msdos',
         "Making Partition Label");
ex_quiet('parted --script ' . $dev_device . ' mkpart primary linux-swap 0 ' .
         $swap_size_mb,
         "Making Swap Partition");
ex_quiet('parted --script ' . $dev_device . ' mkpart primary ext2 ' .
         $swap_size_mb . ' ' . ($image_size_b/1024/1024),
         "Making Root Partition");
ex_quiet('kpartx -av ' . $dev_device, "Creating Partition Device Mappings");
my $dev_device_num = $dev_device;
$dev_device_num =~ s/.*\/loop//g;
my $dev_partition = '/dev/mapper/loop' . $dev_device_num;
ex_quiet('mkswap ' . $dev_partition . 'p0', "Formatting Swap Partition");
ex_quiet('mkfs.ext3 ' . $dev_partition . 'p1', "Formatting Root Partition");
ex_quiet('mkdir -p ' . $mount_dir, "Creating Temporary Mount Directory");
ex_quiet('mount ' . $dev_partition . 'p1 ' . $mount_dir,
         "Mounting Loopback Device");



clean_env();
